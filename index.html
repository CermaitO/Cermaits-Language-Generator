<!DOCTYPE html>
<html>
  <head>
    <title>Kerbeluko Language Generator</title>
    <link href="style.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>

  <body>
    <header>
      <div id="title-div">
        <h1>Kerbeluko</h1>
        <p id="subtitle">Inflector</p>
      </div>
    </header>

    <section id="intro">
      <h1>What is Kerbeluko?</h1>

      <p>
        Kerbeluko is a fictional language, made up purely for the purposes of
        this generator, which I made to practice JavaScript while indulging in
        my love of languages. Kerbeluko has a fixed set of affixes and a fixed
        morphophonology, however I have not created any words because that would
        take the fun away from this generator! Here, you can create the words
        yourself and see how they inflect and compound together. Scroll down to
        the bottom to see the generator!
      </p>

      <h1>Morphology</h1>

      <p>
        Kerbeluko nouns have two grammatical numbers, singular and plural, and
        three noun cases, nominative, accusative and genitive.
        <a href="https://en.wikipedia.org/wiki/Grammatical_case" target="_blank"
          >What are noun cases?</a
        >.<br />
        Grammatical number is marked with two suffixes: <i>-ko</i> marks the
        singular and <i>-te</i> marks the plural.<br /><br />
        <i>-gu-</i> "eye"
      </p>

      <ul>
        <li><i>gu-ko</i> "eye"</li>
        <li><i>gu-te</i> "eyes"</li>
      </ul>

      <p>
        Noun case is marked with two prefixes: <i>he-</i> for the accusative and
        <i>pi-</i> for the genitive. The nominative case is unmarked.<br />

        Noun case and number combine in an agglutinative fashion, so a singular
        accusative noun has the prefix <i>he-</i> and the suffix <i>-ko</i>
      </p>

      <ul>
        <li><i>he-gu-ko</i> "eye" (accusative)</li>
        <li><i>he-gu-te</i> "eyes" (accusative)</li>
        <li><i>pi-gu-ko</i> "eye's" (genitive)</li>
        <li><i>pi-gu-te</i> "eyes'" (genitive)</li>
      </ul>

      <h1>Phonology</h1>

      <p>
        Kerbeluko has five vowel qualities: /i, u, e ,o , a/, and two vowel
        quantities: long and short. Long vowels only appear as a result of sound
        changes which will be discussed below.<br />There is also the vowel
        schwa <i>ə</i> but this only occurs as a result of the syllabification
        of <i>l</i> and <i>r</i> and thus is not a phonemic vowel.<br />
        The consonants are:<br />
      </p>
      <ul>
        <li><b>Nasals</b>: /m, n/</li>
        <li><b>Plosives</b>: /p, b, t, d, k, g/</li>
        <li><b>Fricatives</b>: /f, s, h/</li>
        <li><b>Sonorants</b>: /r, l/</li>
        <li><b>Approximants</b>: /j, w/</li>
      </ul>

      <p>
        Kerbeluko has the following possible root structures (C = consonant, V =
        vowel):
      </p>
      <ul>
        <li><b>CV</b>: <i>-gu-</i></li>
        <li><b>CVC</b>: <i>-mud-</i></li>
        <li><b>CVCV</b>: <i>-weri-</i></li>
        <li><b>CVCVC</b>: <i>-regon-</i></li>
        <li><b>CVCC</b>: <i>-murk-</i></li>
        <li><b>CVCCV</b>: <i>-dormu-</i></li>
      </ul>

      <h2>Morphophonology</h2>

      <p>
        When different morphemes are concatenated together, such as attaching a
        prefix or suffix, or compounding two roots together, several sound
        changes occur. Such that the root <i>-gu-</i> "eye" with the singular
        suffix <i>-ko</i> and accusative prefix <i>he-</i> does not create
        <i>*heguko</i> but <i>hēhko</i>. The rules are as follows.
      </p>

      <h3>Syncope</h3>

      <p>
        In a word with that is at least three syllables long, the vowel in the
        second syllable is lost and the vowel in the first syllable becomes
        long: <i>he-lu-ko</i> > <i>hēlko</i>, <i>weri-ko</i> >
        <i>wērko</i>.<br />
        However, if the vowel of the second syllable is surrounded by two of the
        same consonant, then it is the vowel of the third syllable that is lost
        and the vowel of the second syllable becomes long: <i>rako-ko</i> >
        <i>rakōk</i>.
      </p>

      <p>
        In a word that is two syllables long or more, but the first syllable is
        heavy (has a consonant following the vowel), then the vowel of the
        second syllable is lost and the vowel of the first syllable becomes
        long. The first consonant of the second syllable is also lost:
        <i>gim-ko</i> > <i>gīmo</i>. For such nouns, the singular suffix
        <i>-ko</i> and plural suffix <i>-te</i> become <i>-o</i> and <i>-te</i>:
        <i>-gim-</i> > <i>gīmo, gīme</i><br />
        If the first syllable was super-heavy (has two consonant following the
        vowel) then the second consonant of the first syllable is lost:
        <i>pand-ko</i> > <i>pānko</i>.
      </p>

      <h3>Lenition</h3>

      <p>
        Kerbeluko does not allow a plosive to cluster before a cluster of the
        same place of articulation. when such clusters occur, the first plosive
        lenites to a voiceless fricative. If the second plosive was voiced, it
        devoices after the fricative<br />
      </p>
      <ul>
        <li>
          <b>pb, bp</b> > <b>fp</b>: <i>bego-ko</i> > <i>bēgko</i> >
          <i>bēhko</i>; <i>he-wirpbego-ko</i> > <i>hēurpbegoko</i> >
          <i>hēurfpegoko</i>
        </li>
        <li>
          <b>dt, td</b> > <b>st</b>: <i>mud-te</i> > <i>muste</i>;
          <i>he-ritdolm-ko</i> > <i>hērtdolmgo</i> > <i>hērstolmgo</i>
        </li>
        <li>
          <b>kg, gk</b> > <b>hk</b>: <i>bego-ko</i> > <i>bēgko</i> >
          <i>bēhko</i>
        </li>
      </ul>

      <h3>Metathesis</h3>

      <p>
        The cluster <i>bm</i> becomes <i>mb</i>: <i>durib-melon-ko</i> >
        <i>dūrmbelonko</i>
      </p>

      <h3>Voicing of mC clusters</h3>

      <p>Voiceless plosives become voiced when after <i>m</i>.</p>

      <ul>
        <li>
          <b>mp</b> > <b>mb</b>: <i>kerem-parki-ko</i> > <i>kērmbarkiko</i>
        </li>
        <li><b>mt</b> > <b>md</b>: <i>barum-te</i> > <i>bārmde</i></li>
        <li>
          <b>mk</b> > <b>mg</b>: <i>pergo-losem-ko</i> > <i>pērolosemgo</i>
        </li>
      </ul>

      <h3>Syllabification</h3>

      <p>
        If <i>w</i> or <i>j</i> are made to occur before a consonant, as a
        result of syncope, then they syllabify into <i>u</i> and
        <i>i</i> respectively: <i>dawo-ko</i> > <i>dāwko</i> > <i>dāuko</i>;
        <i>suje-te</i> > <i>sūjte</i> > <i>sūite</i>.
      </p>

      <p>
        The sonorants <i>r</i> and <i>l</i> syllabify into a schwa <i>ə</i> but
        only when they are both before and after a consonant. The schwa is
        unaffected by syncope, as this syllabification occurs after syncope
        takes place: <i>he-mul-ko</i> > <i>hēmlko</i> > <i>hēməko</i>;
        <i>tebor-te</i> > <i>tēbrte</i> > <i>tēbəte</i>.
      </p>

      <h3>Loss of /h/ After Consonants</h3>

      <p>
        The consonant /h/, which occurs in Kerbeluko exclusively as a result og
        <i>kg, gk</i> > <i>hk</i>, is lost when it occurs after another
        consonant: <i>sebeg-ko</i> > <i>sēbgko</i> > <i>sēbhko</i> >
        <i>sēbko</i>.
      </p>

      <h3>Shortening of Geminates</h3>

      <p>
        Two of the same consonants may cluster together as a result of
        compounding. Kerbeluko avoids these clusters by shortening the geminate
        consonants into one single short consonant: <i>balis-sol-ko</i> >
        <i>bālssolko</i> > <i>bālsolko</i>
      </p>
    </section>

    <section id="inputSection">
      <h1>Kerbeluko Inflector</h1>

      <p>
        Use this tool to see how any Kerbeluko root would inflect and compound
        with other roots! You can insert any roots that you want, even ones that
        you made up! So long as they follow Kerbeluko's root structure! It is
        possible to ignore Kerbeluko's root structure and add letters that don't
        occur in Kerbeluko, but the results won't be accurate, but you can play
        with this also if you wish. Enter as many words as you want, be sure to
        divide each word with a blank space, don't use commas.<br /><br />
        Here are some roots that you can start with:<br />
        Roots: gu bego mud lu gim weri diwo sab regon<br />
        Meanings: eye hill head bone eagle cloud blood sword boat
      </p>

      <div class="input-container">
        <p>Enter Kerbeluko Roots Here:</p>
        <input type="textarea" id="inputRoot" />
      </div>
      <div class="input-container">
        <p>Enter Their Meanings Here:</p>
        <input type="textarea" id="inputMeaning" />
      </div>
      <div id="button-div">
        <input type="submit" value="Submit" id="submit" />
        <input type="submit" value="Clear Input" id="clear-input" />
      </div>
    </section>

    <section id="outputSection"></section>

    <script src="scripts\soundchange.js" />

    //for some reason, the javascript would only work on deployment if included
    //in a script tag in the html file, but would not work when linked.
    <script>
      let submitButton = document.getElementById("submit");
      let clearButton = document.getElementById("clear-input");

      submitButton.addEventListener("click", createArrays);
      clearButton.addEventListener("click", clearOutput);

      function clearOutput() {
        //clears previous results upon clicking "Clear Output"
        outputSection.replaceChildren();
        document.getElementById("inputRoot").value = "";
        document.getElementById("inputMeaning").value = "";
      }

      /*------------SOUND CHANGES------------------------------------------------------*/

      function soundChange(word) {
        let vowels = ["a", "ā", "e", "ē", "o", "ō", "u", "ū", "i", "ī", "ə"];

        let consonants = [
          "m",
          "n",
          "p",
          "b",
          "t",
          "d",
          "k",
          "g",
          "f",
          "v",
          "s",
          "z",
          "h",
          "l",
          "r",
          "j",
          "w",
        ];

        letterArray =
          Array.from(word); /*turns string into an array of individual letters*/

        /*---------SYNCOPE-----------*/
        //removes the fourth letter of words longer than four letters, and lengthens the first vowel, or if the third and fourth letters are the same, removes the fifth letter abd lengthens the fourth letter
        if (letterArray.length > 4) {
          if (letterArray[2] == letterArray[4]) {
            //check's if the third and fourth letter are the same
            letterArray.splice([5], 1); // 2nd parameter means remove one item only
            if (letterArray[3] == "o") {
              letterArray[3] = "ō";
            } else if (letterArray[3] == "u") {
              letterArray[3] = "ū";
            } else if (letterArray[3] == "i") {
              letterArray[3] = "ī";
            } else if (letterArray[3] == "e") {
              letterArray[3] = "ē";
            } else if (letterArray[3] == "a") {
              letterArray[3] = "ā";
            }
          } else {
            letterArray.splice([3], 1);
            if (letterArray[1] == "o") {
              letterArray[1] = "ō";
            } else if (letterArray[1] == "u") {
              letterArray[1] = "ū";
            } else if (letterArray[1] == "i") {
              letterArray[1] = "ī";
            } else if (letterArray[1] == "e") {
              letterArray[1] = "ē";
            } else if (letterArray[1] == "a") {
              letterArray[1] = "ā";
            }
          }
        }

        let syncopedString = letterArray.join(""); //turns the array back into a string

        let lenitionString0 = syncopedString.replace("pb", "fp");
        let lenitionString1 = lenitionString0.replace("bp", "fp");
        let lenitionString2 = lenitionString1.replace("gk", "hk");
        let lenitionString3 = lenitionString2.replace("kg", "hk");
        let lenitionString4 = lenitionString3.replace("dt", "st");
        let lenitionString5 = lenitionString4.replace("td", "st");
        let lenitionString6 = lenitionString5.replace("bm", "mb");
        let lenitionString7 = lenitionString6.replace("mt", "md");
        let lenitionString8 = lenitionString7.replace("mp", "mb");
        let lenitionString9 = lenitionString8.replace("mk", "mg");

        let furtherChanges = Array.from(lenitionString9);

        let rejoinedString = furtherChanges.join(""); //turns the array back into a string

        //removes "h" if it occurs both after another consonant and before "k". Due to interference with the "h" in the accusative prefix, I had to make this rather clunky workaround. This turns "hk" clusters into "X" (all cases of post-consonantal "h" occur before "h") and then check if "X" if after a consonant, if it is, then "X" becomes "k", else, it becomes "hk" again
        let hKtoX = rejoinedString.replace("hk", "X");
        let beforeX = consonants.includes(hKtoX.charAt(hKtoX.indexOf("X") - 1));
        let removeCX =
          hKtoX.includes("X") && beforeX ? hKtoX.replace("X", "k") : hKtoX;
        let returnXtoHK = removeCX.replace("X", "hk");

        //checks if "j" occurs before a consonant and turns it into "i"
        let syllabliseJ =
          returnXtoHK.includes("j") &&
          consonants.includes(returnXtoHK.charAt(returnXtoHK.indexOf("j") + 1))
            ? returnXtoHK.replace("j", "i")
            : returnXtoHK;

        //checks if "w" occurs before a consonant and turns it into "u"
        let syllabliseW =
          syllabliseJ.includes("w") &&
          consonants.includes(syllabliseJ.charAt(syllabliseJ.indexOf("w") + 1))
            ? syllabliseJ.replace("w", "u")
            : syllabliseJ;

        //checks if "r" is before and after a consonant, and turns it into schwa if so
        let syllabliseR =
          syllabliseW.includes("r") &&
          consonants.includes(
            syllabliseW.charAt(syllabliseW.indexOf("r") + 1)
          ) &&
          consonants.includes(syllabliseW.charAt(syllabliseW.indexOf("r") - 1))
            ? syllabliseJ.replace("r", "ə")
            : syllabliseW;

        //checks if "l" is before and after a consonant, and turns it into schwa if so
        let syllabliseL =
          syllabliseW.includes("l") &&
          consonants.includes(
            syllabliseW.charAt(syllabliseW.indexOf("l") + 1)
          ) &&
          consonants.includes(syllabliseW.charAt(syllabliseW.indexOf("l") - 1))
            ? syllabliseJ.replace("l", "ə")
            : syllabliseR;

        //turns geminates into singletons
        let reduceGeminate = syllabliseL.replace("pp", "p");
        let reduceGeminate1 = reduceGeminate.replace("bb", "b");
        let reduceGeminate2 = reduceGeminate1.replace("tt", "t");
        let reduceGeminate3 = reduceGeminate2.replace("dd", "d");
        let reduceGeminate4 = reduceGeminate3.replace("kk", "k");
        let reduceGeminate5 = reduceGeminate4.replace("gg", "g");
        let reduceGeminate6 = reduceGeminate5.replace("ss", "s");
        let reduceGeminate7 = reduceGeminate6.replace("ll", "l");
        let reduceGeminate8 = reduceGeminate7.replace("rr", "r");
        let reduceGeminate9 = reduceGeminate8.replace("nn", "n");
        let reduceGeminate10 = reduceGeminate9.replace("mm", "m");
        let reduceGeminate11 = reduceGeminate10.replace("hh", "h");

        let fixMacronUPlusU = reduceGeminate11.replace("ūu", "ū");
        let fixUPlusMacronU = fixMacronUPlusU.replace("uū", "ū");
        let fixMacronIPlusI = fixUPlusMacronU.replace("īi", "ī");
        let fixIPlusMacronI = fixMacronIPlusI.replace("iī", "ī");

        return fixIPlusMacronI;
      }

      /*-----------^^^-SOUND CHANGES-^^^-----------------------------------------------------*/

      //Takes the words from both text fields and splits them into arrays, then it creates an object using both arrays.
      function createArrays() {
        let outputSection = document.getElementById("outputSection");
        outputSection.replaceChildren(); //clears the previous output upon refreshing the page

        //Creates a div to contain the root inflection tables, and adds an h1 to it.
        let inflectionDiv = document.createElement("div");
        inflectionDiv.classList.add("inflection-output");
        let inflectionH1 = document.createElement("h1");
        inflectionH1.innerHTML = "Inflected Roots";
        inflectionDiv.appendChild(inflectionH1);
        outputSection.appendChild(inflectionDiv);

        //Creates a div to contain the compound inflection tables, and adds an h1 to it.
        let compoundDiv = document.createElement("div");
        compoundDiv.classList.add("compound-output");
        let compoundH1 = document.createElement("h1");
        compoundH1.innerHTML = "Compounds";
        compoundDiv.appendChild(compoundH1);
        outputSection.appendChild(compoundDiv);

        let inputRoot = document.getElementById("inputRoot").value;
        let splitInputRoot = inputRoot.split(" ");
        let inputMeaning = document.getElementById("inputMeaning").value;
        let splitInputMeaning = inputMeaning.split(" ");

        /*-----------------------INFLECTION HEADWORD--------------------------------------------------------------*
    
/* Generates the headword above each inflection table, showing the root and it's meaning as a title */
        for (i = 0; i < splitInputRoot.length; i++) {
          let root = splitInputRoot[i];
          let rootMeaning = splitInputMeaning[i];

          /*Creates a new p element to which is appended the root*/
          let newHeadingProot = document.createElement("P");
          newHeadingProot.classList.add("headingProot");
          let newHeadingProotContent = document.createTextNode(
            "-" + root + "-"
          );
          newHeadingProot.appendChild(newHeadingProotContent);

          /*Creates a new p element to which is appended the root's meaning*/
          let newHeadingPmeaning = document.createElement("p");
          newHeadingPmeaning.classList.add("headingPmeaning");
          let newHeadingPmeaningContent = document.createTextNode(
            '"' + rootMeaning + '"'
          );
          newHeadingPmeaning.appendChild(newHeadingPmeaningContent);

          /* Creates a new div element to contain both the p elements.*/
          let newHeadWordDiv = document.createElement("div");
          newHeadWordDiv.classList.add("headWordDiv");
          newHeadWordDiv.appendChild(newHeadingProot);
          newHeadWordDiv.appendChild(newHeadingPmeaning);

          inflectionDiv.appendChild(newHeadWordDiv);

          /*----------------------^^^-HEADWORD-^^^-------------------------------------------------------------*/

          /*-----------------------INFLECTION TABLE--------------------------------------------------------------*/
          /*Generates a table below the headword, showing how the root is inflected.*/

          let newTable = document.createElement("table");
          inflectionDiv.appendChild(newTable);

          for (j = 0; j < 4; j++) {
            let newRow = document.createElement("tr");
            newTable.appendChild(newRow);

            let newTD1 = document.createElement("td");
            newTD1.style.fontWeight = "bold";
            newTD1.style.border = "1px solid black";

            let newTD2 = document.createElement("td");
            newTD2.style.border = "1px solid black";
            newTD2.style.borderRightStyle = "none";

            let newTD3 = document.createElement("td");
            newTD3.style.fontStyle = "italic";
            newTD3.style.border = "1px solid black";
            newTD3.style.borderLeftStyle = "none";

            let newTD4 = document.createElement("td");
            newTD4.style.border = "1px solid black";
            newTD4.style.borderRightStyle = "none";

            let newTD5 = document.createElement("td");
            newTD5.style.fontStyle = "italic";
            newTD5.style.border = "1px solid black";
            newTD5.style.borderLeftStyle = "none";

            let newTH1 = document.createElement("th");
            newTH1.style.border = "1px solid black";

            let newTH2 = document.createElement("th");
            newTH2.style.border = "1px solid black";

            let newTH3 = document.createElement("th");
            newTH3.style.border = "1px solid black";

            let nomSg = root + "ko";
            let nomPl = root + "te";

            let nomSgEtymology = " " + " <" + " " + root + "-" + "ko";
            let nomPlEtymology = " " + " <" + " " + root + "-" + "te";

            let accSg = "he" + root + "ko";
            let accPl = "he" + root + "te";

            let accSgEtymology =
              " " + "<" + " " + "he" + "-" + root + "-" + "ko";
            let accPlEtymology =
              " " + "<" + " " + "he" + "-" + root + "-" + "te";

            let genSg = "pi" + root + "ko";
            let genPl = "pi" + root + "te";

            let genSgEtymology =
              " " + "<" + " " + "pi" + "-" + root + "-" + "ko";
            let genPlEtymology =
              " " + "<" + " " + "pi" + "-" + root + "-" + "te";

            if (j == 0) {
              newTH1.innerHTML = " ";
              newTH1.setAttribute("colspan", 1);
              newRow.appendChild(newTH1);

              newTH2.innerHTML = "Sg";
              newTH2.setAttribute("colspan", 2);
              newRow.appendChild(newTH2);

              newTH3.innerHTML = "Pl";
              newTH3.setAttribute("colspan", 2);
              newRow.appendChild(newTH3);
            } else if (j == 1) {
              newTD1.innerHTML = "Nom";
              newRow.appendChild(newTD1);

              newTD2.innerHTML = soundChange(nomSg);
              newRow.appendChild(newTD2);

              newTD3.innerHTML = nomSgEtymology;
              newRow.appendChild(newTD3);

              newTD4.innerHTML = soundChange(nomPl);
              newRow.appendChild(newTD4);

              newTD5.innerHTML = nomPlEtymology;
              newRow.appendChild(newTD5);
            } else if (j == 2) {
              newTD1.innerHTML = "Acc";
              newRow.appendChild(newTD1);

              newTD2.innerHTML = soundChange(accSg);
              newRow.appendChild(newTD2);

              newTD3.innerHTML = accSgEtymology;
              newRow.appendChild(newTD3);

              newTD4.innerHTML = soundChange(accPl);
              newRow.appendChild(newTD4);

              newTD5.innerHTML = accPlEtymology;
              newRow.appendChild(newTD5);
            } else if (j == 3) {
              newTD1.innerHTML = "Gen";
              newRow.appendChild(newTD1);

              newTD2.innerHTML = soundChange(genSg);
              newRow.appendChild(newTD2);

              newTD3.innerHTML = genSgEtymology;
              newRow.appendChild(newTD3);

              newTD4.innerHTML = soundChange(genPl);
              newRow.appendChild(newTD4);

              newTD5.innerHTML = genPlEtymology;
              newRow.appendChild(newTD5);
            }
          }
        }

        /*----------------------^^^INFLECTION TABLE-^^^-------------------------------------------------------------*/

        /*-------------COMPOUND------------------------*/
        let compound = "";
        let compoundArray = [];
        let compoundMeaningArray = [];
        for (i = 0; i < splitInputRoot.length; i++) {
          for (j = 0; j < splitInputRoot.length; j++) {
            if (splitInputRoot[i] == splitInputRoot[j]) {
              //prevents a root being compounded with itself
              continue;
            }
            compound = splitInputRoot[i] + splitInputRoot[j];
            compoundMeaning = splitInputMeaning[i] + "-" + splitInputMeaning[j];

            compoundArray.push(compound);

            compoundMeaningArray.push(compoundMeaning);
          }
        }

        /*-----------------------COMPOUND HEADWORD--------------------------------------------------------------*
    
/* Generates the headword above each compound table, showing the compound and it's meaning as a title */
        for (x = 0; x < compoundArray.length; x++) {
          let compoundFromArray = compoundArray[x];
          let compoundMeaningFromArray = compoundMeaningArray[x];

          /*Creates a new p element to which is appended the root*/
          let newHeadingPcompound = document.createElement("p");
          newHeadingPcompound.classList.add("headingProot");
          newHeadingPcompound.innerHTML = compoundFromArray;

          /*Creates a new p element to which is appended the root's meaning */
          let newHeadingPCompoundmeaning = document.createElement("p");
          newHeadingPCompoundmeaning.classList.add("headingPmeaning");
          newHeadingPCompoundmeaning.innerHTML =
            '"' + compoundMeaningFromArray + '"';

          /* Creates a new div element to contain both the p elements.*/
          let newCompoundHeadWordDiv = document.createElement("div");
          newCompoundHeadWordDiv.classList.add("headWordDiv");
          newCompoundHeadWordDiv.appendChild(newHeadingPcompound);
          newCompoundHeadWordDiv.appendChild(newHeadingPCompoundmeaning);

          compoundDiv.appendChild(newCompoundHeadWordDiv);

          /* ----------------------^^^-HEADWORD-^^^-------------------------------------------------------------*/

          /*-----------------------COMPOUND TABLE--------------------------------------------------------------*/
          /*Generates a table below the headword, showing how the root is inflected.*/
          let newCompoundTable = document.createElement("table");
          compoundDiv.appendChild(newCompoundTable);

          for (y = 0; y < 4; y++) {
            let newRowCompound = document.createElement("tr");
            newCompoundTable.appendChild(newRowCompound);

            let newTD1Compound = document.createElement("td");
            newTD1Compound.style.fontWeight = "bold";
            newTD1Compound.style.border = "1px solid black";

            let newTD2Compound = document.createElement("td");
            newTD2Compound.style.border = "1px solid black";
            newTD2Compound.style.borderRightStyle = "none";

            let newTD3Compound = document.createElement("td");
            newTD3Compound.style.fontStyle = "italic";
            newTD3Compound.style.border = "1px solid black";
            newTD3Compound.style.borderLeftStyle = "none";

            let newTD4Compound = document.createElement("td");
            newTD4Compound.style.border = "1px solid black";
            newTD4Compound.style.borderRightStyle = "none";

            let newTD5Compound = document.createElement("td");
            newTD5Compound.style.fontStyle = "italic";
            newTD5Compound.style.border = "1px solid black";
            newTD5Compound.style.borderLeftStyle = "none";

            let newTH1Compound = document.createElement("th");
            newTH1Compound.style.border = "1px solid black";

            let newTH2Compound = document.createElement("th");
            newTH2Compound.style.border = "1px solid black";

            let newTH3Compound = document.createElement("th");
            newTH3Compound.style.border = "1px solid black";

            let nomSgCompound = compoundFromArray + "ko";
            let nomPlCompound = compoundFromArray + "te";

            let nomSgEtymologyCompound =
              " " + " <" + " " + compoundFromArray + "-" + "ko";
            let nomPlEtymologyCompound =
              " " + " <" + " " + compoundFromArray + "-" + "te";

            let accSgCompound = "he" + compoundFromArray + "ko";
            let accPlCompound = "he" + compoundFromArray + "te";

            let accSgEtymologyCompound =
              " " + "<" + " " + "he" + "-" + compoundFromArray + "-" + "ko";
            let accPlEtymologyCompound =
              " " + "<" + " " + "he" + "-" + compoundFromArray + "-" + "te";

            let genSgCompound = "pi" + compoundFromArray + "ko";
            let genPlCompound = "pi" + compoundFromArray + "te";

            let genSgEtymologyCompound =
              " " + "<" + " " + "pi" + "-" + compoundFromArray + "-" + "ko";
            let genPlEtymologyCompound =
              " " + "<" + " " + "pi" + "-" + compoundFromArray + "-" + "te";

            if (y == 0) {
              newTH1Compound.innerHTML = " ";
              newTH1Compound.setAttribute("colspan", 1);
              newRowCompound.appendChild(newTH1Compound);

              newTH2Compound.innerHTML = "Sg";
              newTH2Compound.setAttribute("colspan", 2);
              newRowCompound.appendChild(newTH2Compound);

              newTH3Compound.innerHTML = "Pl";
              newTH3Compound.setAttribute("colspan", 2);
              newRowCompound.appendChild(newTH3Compound);
            } else if (y == 1) {
              newTD1Compound.innerHTML = "Nom";
              newRowCompound.appendChild(newTD1Compound);

              newTD2Compound.innerHTML = soundChange(nomSgCompound);
              newRowCompound.appendChild(newTD2Compound);

              newTD3Compound.innerHTML = nomSgEtymologyCompound;
              newRowCompound.appendChild(newTD3Compound);

              newTD4Compound.innerHTML = soundChange(nomPlCompound);
              newRowCompound.appendChild(newTD4Compound);

              newTD5Compound.innerHTML = nomPlEtymologyCompound;
              newRowCompound.appendChild(newTD5Compound);
            } else if (y == 2) {
              newTD1Compound.innerHTML = "Acc";
              newRowCompound.appendChild(newTD1Compound);

              newTD2Compound.innerHTML = soundChange(accSgCompound);
              newRowCompound.appendChild(newTD2Compound);

              newTD3Compound.innerHTML = accSgEtymologyCompound;
              newRowCompound.appendChild(newTD3Compound);

              newTD4Compound.innerHTML = soundChange(accPlCompound);
              newRowCompound.appendChild(newTD4Compound);

              newTD5Compound.innerHTML = accPlEtymologyCompound;
              newRowCompound.appendChild(newTD5Compound);
            } else if (y == 3) {
              newTD1Compound.innerHTML = "Gen";
              newRowCompound.appendChild(newTD1Compound);

              newTD2Compound.innerHTML = soundChange(genSgCompound);
              newRowCompound.appendChild(newTD2Compound);

              newTD3Compound.innerHTML = genSgEtymologyCompound;
              newRowCompound.appendChild(newTD3Compound);

              newTD4Compound.innerHTML = soundChange(genPlCompound);
              newRowCompound.appendChild(newTD4Compound);

              newTD5Compound.innerHTML = genPlEtymologyCompound;
              newRowCompound.appendChild(newTD5Compound);
            }
          }
        }

        /*----------------------^^^COMPOUND TABLE-^^^-------------------------------------------------------------*/
      }
    </script>
  </body>
</html>
